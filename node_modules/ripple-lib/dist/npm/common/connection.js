'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _ = require('lodash');

var _require = require('events');

var EventEmitter = _require.EventEmitter;

var WebSocket = require('ws');
var parseURL = require('url').parse;
var RangeSet = require('./rangeset').RangeSet;

var _require2 = require('./errors');

var RippledError = _require2.RippledError;
var DisconnectedError = _require2.DisconnectedError;
var NotConnectedError = _require2.NotConnectedError;
var TimeoutError = _require2.TimeoutError;
var ResponseFormatError = _require2.ResponseFormatError;
var ConnectionError = _require2.ConnectionError;


function isStreamMessageType(type) {
  return type === 'ledgerClosed' || type === 'transaction' || type === 'path_find';
}

var Connection = function (_EventEmitter) {
  _inherits(Connection, _EventEmitter);

  function Connection(url) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, Connection);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Connection).call(this));

    _this.setMaxListeners(Infinity);
    _this._url = url;
    _this._trace = options.trace;
    if (_this._trace) {
      // for easier unit testing
      _this._console = console;
    }
    _this._proxyURL = options.proxy;
    _this._proxyAuthorization = options.proxyAuthorization;
    _this._authorization = options.authorization;
    _this._trustedCertificates = options.trustedCertificates;
    _this._key = options.key;
    _this._passphrase = options.passphrase;
    _this._certificate = options.certificate;
    _this._timeout = options.timeout || 20 * 1000;
    _this._isReady = false;
    _this._ws = null;
    _this._ledgerVersion = null;
    _this._availableLedgerVersions = new RangeSet();
    _this._nextRequestID = 1;
    return _this;
  }

  _createClass(Connection, [{
    key: '_updateLedgerVersions',
    value: function _updateLedgerVersions(data) {
      this._ledgerVersion = Number(data.ledger_index);
      if (data.validated_ledgers) {
        this._availableLedgerVersions.reset();
        this._availableLedgerVersions.parseAndAddRanges(data.validated_ledgers);
      } else {
        this._availableLedgerVersions.addValue(this._ledgerVersion);
      }
    }

    // return value is array of arguments to Connection.emit

  }, {
    key: '_parseMessage',
    value: function _parseMessage(message) {
      var data = JSON.parse(message);
      if (data.type === 'response') {
        if (!(Number.isInteger(data.id) && data.id >= 0)) {
          throw new ResponseFormatError('valid id not found in response');
        }
        return [data.id.toString(), data];
      } else if (isStreamMessageType(data.type)) {
        if (data.type === 'ledgerClosed') {
          this._updateLedgerVersions(data);
        }
        return [data.type, data];
      } else if (data.type === undefined && data.error) {
        return ['error', data.error, data.error_message, data]; // e.g. slowDown
      }
      throw new ResponseFormatError('unrecognized message type: ' + data.type);
    }
  }, {
    key: '_onMessage',
    value: function _onMessage(message) {
      var parameters = undefined;
      if (this._trace) {
        this._console.log(message);
      }
      try {
        parameters = this._parseMessage(message);
      } catch (error) {
        this.emit('error', 'badMessage', error.message, message);
        return;
      }
      // we don't want this inside the try/catch or exceptions in listener
      // will be caught
      this.emit.apply(this, _toConsumableArray(parameters));
    }
  }, {
    key: 'isConnected',
    value: function isConnected() {
      return this._state === WebSocket.OPEN && this._isReady;
    }
  }, {
    key: '_onUnexpectedClose',
    value: function _onUnexpectedClose() {
      var resolve = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];
      var reject = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];

      this._ws = null;
      this._isReady = false;
      this.connect().then(resolve, reject);
    }
  }, {
    key: '_onOpen',
    value: function _onOpen() {
      var _this2 = this;

      this._ws.removeListener('close', this._onUnexpectedCloseBound);
      this._onUnexpectedCloseBound = this._onUnexpectedClose.bind(this);
      this._ws.once('close', this._onUnexpectedCloseBound);

      var request = {
        command: 'subscribe',
        streams: ['ledger']
      };
      return this.request(request).then(function (data) {
        _this2._updateLedgerVersions(data);
        _this2._isReady = true;
        _this2.emit('connected');
      });
    }
  }, {
    key: '_createWebSocket',
    value: function _createWebSocket() {
      var options = {};
      if (this._proxyURL !== undefined) {
        var parsedURL = parseURL(this._url);
        var parsedProxyURL = parseURL(this._proxyURL);
        var proxyOverrides = _.omit({
          secureEndpoint: parsedURL.protocol === 'wss:',
          secureProxy: parsedProxyURL.protocol === 'https:',
          auth: this._proxyAuthorization,
          ca: this._trustedCertificates,
          key: this._key,
          passphrase: this._passphrase,
          cert: this._certificate
        }, _.isUndefined);
        var proxyOptions = _.assign({}, parsedProxyURL, proxyOverrides);
        var HttpsProxyAgent = undefined;
        try {
          HttpsProxyAgent = require('https-proxy-agent');
        } catch (error) {
          throw new Error('"proxy" option is not supported in the browser');
        }
        options.agent = new HttpsProxyAgent(proxyOptions);
      }
      if (this._authorization !== undefined) {
        var base64 = new Buffer(this._authorization).toString('base64');
        options.headers = { Authorization: 'Basic ' + base64 };
      }
      var optionsOverrides = _.omit({
        ca: this._trustedCertificates,
        key: this._key,
        passphrase: this._passphrase,
        cert: this._certificate
      }, _.isUndefined);
      var websocketOptions = _.assign({}, options, optionsOverrides);
      var websocket = new WebSocket(this._url, null, websocketOptions);
      // we will have a listener for each outstanding request,
      // so we have to raise the limit (the default is 10)
      if (typeof websocket.setMaxListeners === 'function') {
        websocket.setMaxListeners(Infinity);
      }
      return websocket;
    }
  }, {
    key: 'connect',
    value: function connect() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (!_this3._url) {
          reject(new ConnectionError('Cannot connect because no server was specified'));
        }
        if (_this3._state === WebSocket.OPEN) {
          resolve();
        } else if (_this3._state === WebSocket.CONNECTING) {
          _this3._ws.once('open', resolve);
        } else {
          _this3._ws = _this3._createWebSocket();
          // when an error causes the connection to close, the close event
          // should still be emitted; the "ws" documentation says: "The close
          // event is also emitted when then underlying net.Socket closes the
          // connection (end or close)."
          _this3._ws.on('error', function (error) {
            return _this3.emit('error', 'websocket', error.message, error);
          });
          _this3._ws.on('message', _this3._onMessage.bind(_this3));
          // in browser close event can came before open event, so we must
          // resolve connect's promise after reconnect in that case.
          // after open event we will rebound _onUnexpectedCloseBound
          // without resolve and reject functions
          _this3._onUnexpectedCloseBound = _this3._onUnexpectedClose.bind(_this3, resolve, reject);
          _this3._ws.once('close', _this3._onUnexpectedCloseBound);
          _this3._ws.once('open', function () {
            return _this3._onOpen().then(resolve, reject);
          });
        }
      });
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      var _this4 = this;

      return new Promise(function (resolve) {
        if (_this4._state === WebSocket.CLOSED) {
          resolve();
        } else if (_this4._state === WebSocket.CLOSING) {
          _this4._ws.once('close', resolve);
        } else {
          _this4._ws.removeListener('close', _this4._onUnexpectedCloseBound);
          _this4._ws.once('close', function () {
            _this4._ws = null;
            _this4._isReady = false;
            resolve();
          });
          _this4._ws.close();
        }
      });
    }
  }, {
    key: 'reconnect',
    value: function reconnect() {
      var _this5 = this;

      return this.disconnect().then(function () {
        return _this5.connect();
      });
    }
  }, {
    key: '_whenReady',
    value: function _whenReady(promise) {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        if (!_this6._shouldBeConnected) {
          reject(new NotConnectedError());
        } else if (_this6._state === WebSocket.OPEN && _this6._isReady) {
          promise.then(resolve, reject);
        } else {
          _this6.once('connected', function () {
            return promise.then(resolve, reject);
          });
        }
      });
    }
  }, {
    key: 'getLedgerVersion',
    value: function getLedgerVersion() {
      return this._whenReady(Promise.resolve(this._ledgerVersion));
    }
  }, {
    key: 'hasLedgerVersions',
    value: function hasLedgerVersions(lowLedgerVersion, highLedgerVersion) {
      return this._whenReady(Promise.resolve(this._availableLedgerVersions.containsRange(lowLedgerVersion, highLedgerVersion || this._ledgerVersion)));
    }
  }, {
    key: 'hasLedgerVersion',
    value: function hasLedgerVersion(ledgerVersion) {
      return this.hasLedgerVersions(ledgerVersion, ledgerVersion);
    }
  }, {
    key: '_send',
    value: function _send(message) {
      var _this7 = this;

      if (this._trace) {
        this._console.log(message);
      }
      return new Promise(function (resolve, reject) {
        _this7._ws.send(message, undefined, function (error, result) {
          if (error) {
            reject(new DisconnectedError(error.message));
          } else {
            resolve(result);
          }
        });
      });
    }
  }, {
    key: 'request',
    value: function request(_request, timeout) {
      var _this8 = this;

      return new Promise(function (resolve, reject) {
        if (!_this8._shouldBeConnected) {
          reject(new NotConnectedError());
        }

        var timer = null;
        var self = _this8;
        var id = _this8._nextRequestID;
        _this8._nextRequestID += 1;
        var eventName = id.toString();

        function onDisconnect() {
          clearTimeout(timer);
          self.removeAllListeners(eventName);
          reject(new DisconnectedError());
        }

        function cleanup() {
          clearTimeout(timer);
          self.removeAllListeners(eventName);
          if (self._ws !== null) {
            self._ws.removeListener('close', onDisconnect);
          }
        }

        function _resolve(response) {
          cleanup();
          resolve(response);
        }

        function _reject(error) {
          cleanup();
          reject(error);
        }

        _this8.once(eventName, function (response) {
          if (response.status === 'error') {
            _reject(new RippledError(response.error));
          } else if (response.status === 'success') {
            _resolve(response.result);
          } else {
            _reject(new ResponseFormatError('unrecognized status: ' + response.status));
          }
        });

        _this8._ws.once('close', onDisconnect);

        // JSON.stringify automatically removes keys with value of 'undefined'
        var message = JSON.stringify(Object.assign({}, _request, { id: id }));

        _this8._whenReady(_this8._send(message)).then(function () {
          var delay = timeout || _this8._timeout;
          timer = setTimeout(function () {
            return _reject(new TimeoutError());
          }, delay);
        }).catch(_reject);
      });
    }
  }, {
    key: '_state',
    get: function get() {
      return this._ws ? this._ws.readyState : WebSocket.CLOSED;
    }
  }, {
    key: '_shouldBeConnected',
    get: function get() {
      return this._ws !== null;
    }
  }]);

  return Connection;
}(EventEmitter);

module.exports = Connection;